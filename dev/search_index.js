var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = GenomicBreedingPlots","category":"page"},{"location":"#GenomicBreedingPlots","page":"Home","title":"GenomicBreedingPlots","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for GenomicBreedingPlots.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [GenomicBreedingPlots]","category":"page"},{"location":"#GenomicBreedingPlots.BarPlots","page":"Home","title":"GenomicBreedingPlots.BarPlots","text":"BarPlots <: PlotsGB\n\nMutable struct for storing bar plots.\n\nFields\n\nlabels::Vector{String}: Vector containing labels for the plots\nplots::Vector{CairoMakie.Figure}: Vector containing the bar plot figures\n\n\n\n\n\n","category":"type"},{"location":"#GenomicBreedingPlots.BoxPlots","page":"Home","title":"GenomicBreedingPlots.BoxPlots","text":"BoxPlots <: PlotsGB\n\nMutable struct for storing box plots.\n\nFields\n\nlabels::Vector{String}: Vector containing labels for the plots\nplots::Vector{CairoMakie.Figure}: Vector containing the box plot figures\n\n\n\n\n\n","category":"type"},{"location":"#GenomicBreedingPlots.CorHeatPlots","page":"Home","title":"GenomicBreedingPlots.CorHeatPlots","text":"CorHeatPlots <: PlotsGB\n\nMutable struct for storing correlation heatmap plots.\n\nFields\n\nlabels::Vector{String}: Vector containing labels for the plots\nplots::Vector{CairoMakie.Figure}: Vector containing the correlation heatmap figures\n\n\n\n\n\n","category":"type"},{"location":"#GenomicBreedingPlots.DistributionPlots","page":"Home","title":"GenomicBreedingPlots.DistributionPlots","text":"DistributionPlots <: PlotsGB\n\nMutable struct for storing distribution plots.\n\nFields\n\nlabels::Vector{String}: Vector containing labels for the plots\nplots::Vector{CairoMakie.Figure}: Vector containing the distribution plot figures\n\n\n\n\n\n","category":"type"},{"location":"#GenomicBreedingPlots.PCBiPlots","page":"Home","title":"GenomicBreedingPlots.PCBiPlots","text":"PCBiPlots <: PlotsGB\n\nMutable struct for storing principal component or biplot visualizations.\n\nFields\n\nlabels::Vector{String}: Vector containing labels for the plots\nplots::Vector{CairoMakie.Figure}: Vector containing the PC/biplot figures\n\n\n\n\n\n","category":"type"},{"location":"#GenomicBreedingPlots.PlotsGB","page":"Home","title":"GenomicBreedingPlots.PlotsGB","text":"abstract type PlotsGB end\n\nAbstract type representing the base type for various plotting structures in GenomicBreedingPlots.\n\n\n\n\n\n","category":"type"},{"location":"#GenomicBreedingPlots.TreePlots","page":"Home","title":"GenomicBreedingPlots.TreePlots","text":"TreePlots <: PlotsGB\n\nMutable struct for storing tree visualization plots.\n\nFields\n\nlabels::Vector{String}: Vector containing labels for the plots\nplots::Vector{CairoMakie.Figure}: Vector containing the tree plot figures\n\n\n\n\n\n","category":"type"},{"location":"#GenomicBreedingPlots.ViolinPlots","page":"Home","title":"GenomicBreedingPlots.ViolinPlots","text":"ViolinPlots <: PlotsGB\n\nMutable struct for storing violin plots.\n\nFields\n\nlabels::Vector{String}: Vector containing labels for the plots\nplots::Vector{CairoMakie.Figure}: Vector containing the violin plot figures\n\n\n\n\n\n","category":"type"},{"location":"#GenomicBreedingCore.checkdims-Tuple{PlotsGB}","page":"Home","title":"GenomicBreedingCore.checkdims","text":"checkdims(x::PlotsGB)::Bool\n\nCheck if dimensions of labels and plots match in a PlotsGB object.\n\nArguments\n\nx::PlotsGB: A PlotsGB object containing labels and plots\n\nReturns\n\nBool: true if the number of labels equals the number of plots, false otherwise\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingPlots.labeltofname-Tuple{}","page":"Home","title":"GenomicBreedingPlots.labeltofname","text":"labeltofname(; label::String, prefix::String, suffix::String)::String\n\nConvert a label string into a valid filename by replacing special characters.\n\nThis function takes a label string and converts it into a filename-safe string by:\n\nReplacing common symbols with underscores\nAdding a prefix and suffix\nCleaning up repeated separators\n\nArguments\n\nlabel::String: The input label to be converted\nprefix::String: String to prepend to the filename\nsuffix::String: The file extension (without the dot)\n\nReturns\n\nString: A cleaned filename string with format \"prefix-label.suffix\"\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingPlots.plot-Union{Tuple{T}, Tuple{Type{T}, GenomicBreedingCore.Genomes}} where T<:CorHeatPlots","page":"Home","title":"GenomicBreedingPlots.plot","text":"plot(type::Type{T}, genomes::Genomes; kwargs...)::T where {T<:CorHeatPlots}\n\nGenerate correlation heatmap plots for genome data.\n\nArguments\n\ntype::Type{T}: The type of plot to generate (must be a subtype of CorHeatPlots)\ngenomes::Genomes: The genome data structure to analyze\n\nKeywords\n\nn_loci_alleles::Int64 = 1_000: Maximum number of loci alleles to include in the plot\nseed::Int64 = 42: Random seed for reproducibility\nplot_size::Tuple{Int64,Int64} = (600, 450): Size of each plot in pixels\ncolour_scheme::Symbol = :viridis: Color scheme for the heatmap\nrev_label_colors::Bool = false: If true, reverses the text color threshold for labels\nn_threshold_to_show_text::Int64 = 1_000: Maximum number of cells before text labels are hidden\n\nReturns\n\nCorHeatPlots: A CorHeatPlots object containing the generated correlation heatmaps\n\nDescription\n\nCreates correlation heatmaps showing relationships between:\n\nLoci alleles across all populations\nEntries across all populations\nLoci alleles within each population\nEntries within each population\n\nEach heatmap includes correlation values and sample sizes for each pair, with automatic text sizing and visibility based on the number of elements being displayed.\n\nThrows\n\nArgumentError: If the Genomes struct dimensions are invalid\n\nExample\n\njulia> genomes = GenomicBreedingCore.simulategenomes(n=300, verbose=false); genomes.populations = StatsBase.sample(string.(\"pop_\", 1:3), length(genomes.entries), replace=true);\n\njulia> hplots = GenomicBreedingPlots.plot(CorHeatPlots, genomes);\n\njulia> fnames = saveplots(hplots, format=\"png\")\n\njulia> rm.(fnames);\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingPlots.plot-Union{Tuple{T}, Tuple{Type{T}, GenomicBreedingCore.Genomes}} where T<:DistributionPlots","page":"Home","title":"GenomicBreedingPlots.plot","text":"plot(type::Type{T}, genomes::Genomes; n_loci_alleles::Int64 = 1_000, seed::Int64 = 42, plot_size::Tuple{Int64,Int64} = (600, 450))::T where {T<:DistributionPlots}\n\nGenerate a density plot of allele frequencies distribution from genomic data.\n\nArguments\n\ntype::Type{T}: The type of plot to generate (must be a subtype of DistributionPlots)\ngenomes::Genomes: A Genomes struct containing the genomic data to plot\nn_loci_alleles::Int64: Number of loci to sample for plotting (default: 1000)\nseed::Int64: Random seed for reproducibility (default: 42)\nplot_size::Tuple{Int64,Int64}: Size of the output plot in pixels (width, height) (default: (600, 450))\n\nReturns\n\nT<:DistributionPlots: A DistributionPlots object containing the generated plot\n\nDescription\n\nThis function creates a density plot showing the distribution of allele frequencies across the sampled loci. It randomly samples a specified number of loci from the genomic data and plots their frequency distribution using CairoMakie.\n\nThrows\n\nArgumentError: If the Genomes struct dimensions are invalid or corrupted\n\nExample\n\njulia> genomes = GenomicBreedingCore.simulategenomes(n=300, verbose=false); genomes.populations = StatsBase.sample(string.(\"pop_\", 1:3), length(genomes.entries), replace=true);\n\njulia> dplots = GenomicBreedingPlots.plot(DistributionPlots, genomes);\n\njulia> fnames = saveplots(dplots)\n\njulia> rm.(fnames);\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingPlots.plot-Union{Tuple{T}, Tuple{Type{T}, GenomicBreedingCore.Genomes}} where T<:PCBiPlots","page":"Home","title":"GenomicBreedingPlots.plot","text":"plot(type::Type{T}, genomes::Genomes; kwargs...)::T where {T<:PCBiPlots}\n\nGenerate Principal Component Analysis (PCA) biplots for genomic data.\n\nArguments\n\ntype::Type{T}: The type of plot to generate (must be a subtype of PCBiPlots)\ngenomes::Genomes: A Genomes struct containing the genomic data to plot\n\nKeywords\n\nn_loci_alleles::Int64=1_000: Maximum number of loci-alleles to include in the analysis\nseed::Int64=42: Random seed for reproducibility\nplot_size::Tuple{Int64,Int64}=(600, 450): Size of the output plots in pixels\ncolour_scheme::Symbol=:tol_muted: Color scheme to use for the plots\n\nReturns\n\nPCBiPlots: A PCBiPlots object containing two plots:\nPCA biplot of entries colored by population\nPCA biplot of loci colored by chromosome\n\nDetails\n\nThe function performs the following operations:\n\nValidates input dimensions\nSamples loci-alleles if necessary\nProcesses allele frequencies matrix\nRemoves columns with zero variance\nPerforms PCA and generates two biplots:\nOne showing the relationship between entries/populations\nOne showing the relationship between loci/chromosomes\n\nThrows\n\nArgumentError: If the Genomes struct is corrupted\nErrorException: If the Genomes struct is too sparse\n\nExamples\n\njulia> genomes = GenomicBreedingCore.simulategenomes(n=300, verbose=false); genomes.populations = StatsBase.sample(string.(\"pop_\", 1:3), length(genomes.entries), replace=true);\n\njulia> pplots = GenomicBreedingPlots.plot(PCBiPlots, genomes);\n\njulia> fnames = saveplots(pplots)\n\njulia> rm.(fnames);\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingPlots.plot-Union{Tuple{T}, Tuple{Type{T}, GenomicBreedingCore.Genomes}} where T<:TreePlots","page":"Home","title":"GenomicBreedingPlots.plot","text":"plot(type::Type{T}, genomes::Genomes; kwargs...)::T where {T<:TreePlots}\n\nGenerate hierarchical clustering dendrograms for a Genomes object.\n\nArguments\n\ntype::Type{T}: The type of plot to generate (must be subtype of TreePlots)\ngenomes::Genomes: A Genomes struct containing genetic data\n\nKeyword Arguments\n\nn_loci_alleles::Int64=1_000: Number of loci-alleles to sample for plotting\nseed::Int64=42: Random seed for reproducibility\nplot_size::Tuple{Int64,Int64}=(600, 450): Size of the output plots in pixels\ncolour_scheme::Symbol=:tol_muted: Color scheme to use for the dendrograms\nhorizontal::Bool=true: If true, plot dendrograms horizontally; if false, vertically\n\nReturns\n\nTreePlots: A TreePlots object containing two dendrograms:\nClustering of loci-alleles based on genotypes\nClustering of entries (samples) based on genotypes\n\nDetails\n\nUses Ward's minimum variance method for hierarchical clustering based on Euclidean distances. The dendrograms are colored using the specified color scheme and optimally ordered for visualization.\n\nThrows\n\nArgumentError: If the Genomes struct dimensions are invalid\n\nExample\n\njulia> genomes = GenomicBreedingCore.simulategenomes(n=300, verbose=false); genomes.populations = StatsBase.sample(string.(\"pop_\", 1:3), length(genomes.entries), replace=true);\n\njulia> tplots = GenomicBreedingPlots.plot(TreePlots, genomes);\n\njulia> fnames = saveplots(tplots)\n\njulia> rm.(fnames);\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingPlots.plot-Union{Tuple{T}, Tuple{Type{T}, GenomicBreedingCore.Genomes}} where T<:ViolinPlots","page":"Home","title":"GenomicBreedingPlots.plot","text":"plot(type::Type{T}, genomes::Genomes; kwargs...)::T where {T<:ViolinPlots}\n\nGenerate a violin plot visualizing allele frequencies across different populations in genomic data.\n\nArguments\n\ntype::Type{T}: The type of plot to generate (must be a subtype of ViolinPlots)\ngenomes::Genomes: A Genomes struct containing genomic data and population information\n\nKeywords\n\nn_loci_alleles::Int64=1_000: Number of loci alleles to sample for plotting\nseed::Int64=42: Random seed for reproducibility\nplot_size::Tuple{Int64,Int64}=(600, 450): Size of the output plot in pixels\ncolour_scheme::Symbol=:viridis: Color scheme to use for the violin plots\n\nReturns\n\nViolinPlots: A ViolinPlots object containing the generated plot\n\nDescription\n\nCreates a horizontal violin plot showing the distribution of allele frequencies for each population in the genomic data. The plot includes population labels with sample sizes and uses different colors for each population.\n\nThrows\n\nArgumentError: If the Genomes struct dimensions are invalid or corrupted\n\nExample\n\njulia> genomes = GenomicBreedingCore.simulategenomes(n=300, verbose=false); genomes.populations = StatsBase.sample(string.(\"pop_\", 1:3), length(genomes.entries), replace=true);\n\njulia> trials, _ = GenomicBreedingCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, verbose=false);\n\njulia> genomes = extractgenomes(trials); genomes.phenotypes[1,1] = missing;\n\njulia> vplots = GenomicBreedingPlots.plot(ViolinPlots, genomes);\n\njulia> fnames = saveplots(vplots)\n\njulia> rm.(fnames);\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingPlots.plot-Union{Tuple{T}, Tuple{Type{T}, GenomicBreedingCore.Phenomes}} where T<:CorHeatPlots","page":"Home","title":"GenomicBreedingPlots.plot","text":"plot(type::Type{T}, phenomes::Phenomes; \n     plot_size::Tuple{Int64,Int64}=(600, 450),\n     colour_scheme::Symbol=:viridis,\n     rev_label_colors::Bool=false,\n     n_threshold_to_show_text::Int64=1_000)::T where {T<:CorHeatPlots}\n\nGenerate correlation heatmap plots for phenotypic data.\n\nCreates multiple correlation heatmaps showing relationships between traits and entries across all populations and within individual populations.\n\nArguments\n\ntype::Type{T}: The type of plot to generate (must be a subtype of CorHeatPlots)\nphenomes::Phenomes: A Phenomes struct containing the phenotypic data to plot\n\nKeywords\n\nplot_size::Tuple{Int64,Int64}: Size of the plot in pixels (width, height)\ncolour_scheme::Symbol: Color scheme for the heatmap (e.g., :viridis)\nrev_label_colors::Bool: If true, reverses the text color threshold for labels\nn_threshold_to_show_text::Int64: Maximum number of cells before text labels are hidden\n\nReturns\n\nCorHeatPlots: A CorHeatPlots object containing correlation heatmaps for:\nTraits across all populations\nEntries across all populations\nTraits within each population\nEntries within each population\n\nNotes\n\nCorrelation values range from -1.0 to 1.0\nText labels show correlation values and sample sizes (when sample sizes vary)\nText color automatically adjusts for readability against the background\nLabels are hidden when the number of cells exceeds n_threshold_to_show_text\n\nThrows\n\nArgumentError: If the Phenomes struct dimensions are corrupted\n\nExample\n\njulia> genomes = GenomicBreedingCore.simulategenomes(n=300, verbose=false); genomes.populations = StatsBase.sample(string.(\"pop_\", 1:3), length(genomes.entries), replace=true);\n\njulia> trials, _ = GenomicBreedingCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, verbose=false);\n\njulia> phenomes = extractphenomes(trials); phenomes.phenotypes[1,1] = missing;\n\njulia> hplots = GenomicBreedingPlots.plot(CorHeatPlots, phenomes);\n\njulia> fnames = saveplots(hplots, format=\"png\")\n\njulia> rm.(fnames);\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingPlots.plot-Union{Tuple{T}, Tuple{Type{T}, GenomicBreedingCore.Phenomes}} where T<:DistributionPlots","page":"Home","title":"GenomicBreedingPlots.plot","text":"plot(type::Type{T}, phenomes::Phenomes; plot_size::Tuple{Int64,Int64}=(600, 450))::T where {T<:DistributionPlots}\n\nCreate density plots for each trait in the provided phenomes data.\n\nArguments\n\ntype::Type{T}: The type of distribution plot to create (must be a subtype of DistributionPlots).\nphenomes::Phenomes: A Phenomes struct containing the phenotypic data to plot.\nplot_size::Tuple{Int64,Int64}: Optional tuple specifying the width and height of each plot in pixels.  Defaults to (600, 450).\n\nReturns\n\nT<:DistributionPlots: A DistributionPlots object containing the generated density plots and their labels.\n\nDetails\n\nThe function creates density plots for each trait in the phenomes data, excluding any missing, NaN, or infinite  values. Only traits with more than 3 valid observations will be plotted. Each plot includes the trait name and  the number of observations in its title.\n\nThrows\n\nArgumentError: If the dimensions of the Phenomes struct are invalid or corrupted.\n\nExample\n\njulia> genomes = GenomicBreedingCore.simulategenomes(n=300, verbose=false); genomes.populations = StatsBase.sample(string.(\"pop_\", 1:3), length(genomes.entries), replace=true);\n\njulia> trials, _ = GenomicBreedingCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, verbose=false);\n\njulia> phenomes = extractphenomes(trials); phenomes.phenotypes[1,1] = missing;\n\njulia> dplots = GenomicBreedingPlots.plot(DistributionPlots, phenomes);\n\njulia> fnames = saveplots(dplots)\n\njulia> rm.(fnames);\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingPlots.plot-Union{Tuple{T}, Tuple{Type{T}, GenomicBreedingCore.Phenomes}} where T<:PCBiPlots","page":"Home","title":"GenomicBreedingPlots.plot","text":"plot(type::Type{T}, phenomes::Phenomes; plot_size::Tuple{Int64,Int64}=(600, 450), colour_scheme::Symbol=:tol_muted)::T where {T<:PCBiPlots}\n\nGenerate Principal Component Analysis (PCA) biplots for phenotypic data.\n\nArguments\n\ntype::Type{T}: The type of plot to generate (must be a subtype of PCBiPlots)\nphenomes::Phenomes: A Phenomes struct containing phenotypic data, populations, and traits\nplot_size::Tuple{Int64,Int64}: Size of the output plots in pixels (width, height)\ncolour_scheme::Symbol: Color scheme to use for the plots (default: :tol_muted)\n\nReturns\n\nPCBiPlots: A PCBiPlots object containing two figures:\nPCA biplot of entries colored by population\nPCA biplot of traits\n\nDetails\n\nThe function performs the following operations:\n\nHandles missing, NaN, and Inf values in the phenotypic data\nStandardizes the data (centers and scales)\nPerforms PCA when more than 2 dimensions are present\nCreates direct trait comparison plots when only 2 dimensions are present\nAdds legends when multiple populations or traits are present\n\nThrows\n\nArgumentError: If the Phenomes struct dimensions are corrupted\nErrorException: If the phenotypic data is too sparse\n\nExamples\n\njulia> genomes = GenomicBreedingCore.simulategenomes(n=300, verbose=false); genomes.populations = StatsBase.sample(string.(\"pop_\", 1:3), length(genomes.entries), replace=true);\n\njulia> pplots = GenomicBreedingPlots.plot(PCBiPlots, genomes);\n\njulia> fnames = saveplots(pplots)\n\njulia> rm.(fnames);\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingPlots.plot-Union{Tuple{T}, Tuple{Type{T}, GenomicBreedingCore.Phenomes}} where T<:TreePlots","page":"Home","title":"GenomicBreedingPlots.plot","text":"plot(type::Type{T}, phenomes::Phenomes; plot_size::Tuple{Int64,Int64}=(600, 450), \n     colour_scheme::Symbol=:tol_light, horizontal::Bool=true, \n     standardise_traits::Bool=true)::T where {T<:TreePlots}\n\nGenerate hierarchical clustering dendrograms for traits and entries based on phenotypic data.\n\nArguments\n\ntype::Type{T}: The type of plot to generate (must be a subtype of TreePlots)\nphenomes::Phenomes: A Phenomes struct containing phenotypic data\nplot_size::Tuple{Int64,Int64}: Size of the output plots in pixels (width, height)\ncolour_scheme::Symbol: Color scheme to use for the dendrogram branches\nhorizontal::Bool: If true, plots dendrograms horizontally; if false, vertically\nstandardise_traits::Bool: If true, standardizes trait values before distance calculation\n\nReturns\n\nA TreePlots object containing two dendrograms:\nTraits dendrogram showing relationships between phenotypic traits\nEntries dendrogram showing relationships between genetic entries\n\nDetails\n\nThe function performs the following operations:\n\nCalculates pairwise Euclidean distances between traits and entries\nPerforms hierarchical clustering using Ward's method\nCreates dendrograms with optimal branch ordering\nAdjusts font sizes automatically based on the number of labels\nUses color schemes from ColorSchemes.jl\n\nThrows\n\nArgumentError: If the dimensions in the Phenomes struct are corrupted\n\nExample\n\njulia> genomes = GenomicBreedingCore.simulategenomes(n=300, verbose=false); genomes.populations = StatsBase.sample(string.(\"pop_\", 1:3), length(genomes.entries), replace=true);\n\njulia> trials, _ = GenomicBreedingCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, verbose=false);\n\njulia> phenomes = extractphenomes(trials); phenomes.phenotypes[1,1] = missing;\n\njulia> tplots = GenomicBreedingPlots.plot(TreePlots, phenomes);\n\njulia> fnames = saveplots(tplots)\n\njulia> rm.(fnames);\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingPlots.plot-Union{Tuple{T}, Tuple{Type{T}, GenomicBreedingCore.Phenomes}} where T<:ViolinPlots","page":"Home","title":"GenomicBreedingPlots.plot","text":"plot(type::Type{T}, phenomes::Phenomes; plot_size::Tuple{Int64,Int64}=(600, 450), colour_scheme::Symbol=:viridis)::T where {T<:ViolinPlots}\n\nCreate violin plots for phenotypic data across different populations.\n\nArguments\n\ntype::Type{T}: The type of plot to create (must be a subtype of ViolinPlots)\nphenomes::Phenomes: A Phenomes struct containing the phenotypic data to visualize\nplot_size::Tuple{Int64,Int64}: Size of the plot in pixels (width, height)\ncolour_scheme::Symbol: Color scheme for the violin plots (default: :viridis)\n\nReturns\n\nT<:ViolinPlots: A ViolinPlots object containing the generated plots and their labels\n\nDetails\n\nThe function creates violin plots for each trait in the phenomes data, showing the distribution of phenotypic values across different populations. Each plot includes:\n\nViolin plots showing the distribution density\nBox plots overlaid on the violin plots\nPopulation counts in the y-axis labels\nHorizontal orientation for better readability\n\nMissing, NaN, and infinite values are automatically filtered out.\n\nThrows\n\nArgumentError: If the Phenomes struct dimensions are corrupted\n\nExample\n\njulia> genomes = GenomicBreedingCore.simulategenomes(n=300, verbose=false); genomes.populations = StatsBase.sample(string.(\"pop_\", 1:3), length(genomes.entries), replace=true);\n\njulia> trials, _ = GenomicBreedingCore.simulatetrials(genomes=genomes, n_years=1, n_seasons=1, n_harvests=1, n_sites=1, n_replications=1, verbose=false);\n\njulia> phenomes = extractphenomes(trials); phenomes.phenotypes[1,1] = missing;\n\njulia> vplots = GenomicBreedingPlots.plot(ViolinPlots, phenomes);\n\njulia> fnames = saveplots(vplots)\n\njulia> rm.(fnames);\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingPlots.plot-Union{Tuple{T}, Tuple{Type{T}, Vector{GenomicBreedingCore.CV}}} where T<:BarPlots","page":"Home","title":"GenomicBreedingPlots.plot","text":"plot(type::Type{T}, cvs::Vector{CV}; metric::String=\"cor\", plot_size::Tuple{Int64,Int64}=(600,450), colour_scheme::Symbol=:viridis)::T where {T<:BarPlots}\n\nGenerate bar plots visualizing cross-validation results from genomic prediction models.\n\nArguments\n\ntype::Type{T}: The type of plot output, must be a subtype of BarPlots\ncvs::Vector{CV}: Vector of cross-validation results objects\nmetric::String=\"cor\": The metric to plot (e.g. \"cor\" for correlation, \"rmse\" for root mean square error)\nplot_size::Tuple{Int64,Int64}=(600,450): Size of the output plots in pixels\ncolour_scheme::Symbol=:viridis: Color scheme to use for the plots\n\nReturns\n\nBarPlots: A BarPlots object containing the generated plots and their labels\n\nDetails\n\nCreates various bar plots showing model performance across:\n\nWithin-population cross-validation results\nAcross-population cross-validation results\n\nFor each case, generates plots showing performance by:\n\nModel\nTrait\nPopulation\n\nWith appropriate grouping and faceting based on the CV structure.\n\nEach bar shows the mean metric value with standard deviation in parentheses.\n\nThrows\n\nArgumentError: If any CV object is corrupted or if the requested metric doesn't exist\n\nExamples\n\njulia> cvs::Vector{CV} = [];\n\njulia> for m in 1:3\n            for t in 1:5\n                for p in 1:4\n                    n = 100\n                    populations = if rand() < 0.5\n                        string.(\"population_\", sample(1:4, n, replace=true))\n                    else\n                        string.(\"population_\", repeat([p], n))\n                    end\n                    entries = string.(\"entry_\", sample(1:1_000, n, replace=true))\n                    for r in 1:5\n                        for f in 1:5\n                            fit = Fit(n = 10, l = 1_000); fit.model = string(\"model_\", m); fit.populations .= string(\"population_\", p); fit.trait = string(\"trait_\", t); fit.metrics = Dict(\"cor\" => rand()/maximum([1, 5*rand()]), \"rmse\" => rand())\n                            cv = CV(\n                                string(\"replication_\", r), \n                                string(\"fold_\", f), \n                                fit, \n                                populations, \n                                entries, \n                                rand(n), \n                                rand(n), \n                                fit.metrics\n                            )\n                            push!(cvs, cv)\n                        end\n                    end\n                end\n            end\n        end;\n\njulia> bplots = GenomicBreedingPlots.plot(BarPlots, cvs);\n\njulia> fnames = saveplots(bplots, overwrite=true)\n\njulia> rm.(fnames);\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingPlots.plot-Union{Tuple{T}, Tuple{Type{T}, Vector{GenomicBreedingCore.CV}}} where T<:BoxPlots","page":"Home","title":"GenomicBreedingPlots.plot","text":"plot(type::Type{T}, cvs::Vector{CV}; metric::String=\"cor\", plot_size::Tuple{Int64,Int64}=(600,450), colour_scheme::Symbol=:viridis)::T where {T<:BoxPlots}\n\nGenerate box plots visualizing cross-validation results from genomic prediction models.\n\nArguments\n\ntype::Type{T}: The type of BoxPlots to generate\ncvs::Vector{CV}: Vector of cross-validation (CV) results\nmetric::String=\"cor\": Metric to plot (e.g. \"cor\" for correlation, \"rmse\" for root mean square error)\nplot_size::Tuple{Int64,Int64}=(600,450): Size of the output plots in pixels\ncolour_scheme::Symbol=:viridis: Color scheme to use for the plots\n\nReturns\n\nBoxPlots: A struct containing labels and plots visualizing the cross-validation results\n\nDetails\n\nCreates box plots showing genomic prediction accuracy metrics across different:\n\nWithin-population cross-validation scenarios\nAcross-population cross-validation scenarios\n\nThe plots are organized by combinations of:\n\nModels\nTraits\nPopulations\nTraining/validation population combinations\n\nEach plot shows the distribution of the specified accuracy metric, with options for:\n\nSingle or multiple groups per trait/model\nHorizontal orientation\nCustom color schemes\nAutomatic sizing and formatting\n\nThrows\n\nArgumentError: If CV elements are corrupted or if specified metric doesn't exist\n\nExample\n\njulia> cvs::Vector{CV} = [];\n\njulia> for m in 1:3\n            for t in 1:5\n                for p in 1:4\n                    n = 100\n                    populations = if rand() < 0.5\n                        string.(\"population_\", sample(1:4, n, replace=true))\n                    else\n                        string.(\"population_\", repeat([p], n))\n                    end\n                    entries = string.(\"entry_\", sample(1:1_000, n, replace=true))\n                    for r in 1:5\n                        for f in 1:5\n                            fit = Fit(n = 10, l = 1_000); fit.model = string(\"model_\", m); fit.populations .= string(\"population_\", p); fit.trait = string(\"trait_\", t); fit.metrics = Dict(\"cor\" => rand()/maximum([1, 5*rand()]), \"rmse\" => rand())\n                            cv = CV(\n                                string(\"replication_\", r), \n                                string(\"fold_\", f), \n                                fit, \n                                populations, \n                                entries, \n                                rand(n), \n                                rand(n), \n                                fit.metrics\n                            )\n                            push!(cvs, cv)\n                        end\n                    end\n                end\n            end\n        end;\n\njulia> bplots = GenomicBreedingPlots.plot(BoxPlots, cvs);\n\njulia> fnames = saveplots(bplots)\n\njulia> rm.(fnames);\n\n\n\n\n\n","category":"method"},{"location":"#GenomicBreedingPlots.saveplots-Tuple{PlotsGB}","page":"Home","title":"GenomicBreedingPlots.saveplots","text":"saveplots(plots::PlotsGB; idx::Vector{Int64}=[0], format::String=\"svg\", \n          prefix::String=\"\", use_labels::Bool=true, overwrite::Bool=false)::Vector{String}\n\nSave plots from a PlotsGB object to files in the specified format.\n\nArguments\n\nplots::PlotsGB: A PlotsGB object containing the plots to be saved\nidx::Vector{Int64}: Indices of plots to save. Default [0] saves all plots\nformat::String: Output file format, one of \"svg\", \"png\", or \"pdf\". Default \"svg\"\nprefix::String: Prefix for output filenames. Default uses type name of plots\nuse_labels::Bool: If true, use plot labels in filenames; if false, use numeric indices. Default true\noverwrite::Bool: If true, overwrite existing files; if false, throw error. Default false\n\nReturns\n\nVector{String}: Vector of filenames where plots were saved\n\nThrows\n\nArgumentError: If plots object is corrupted, indices are invalid, or format is unsupported\nErrorException: If attempting to overwrite existing files when overwrite=false\n\n\n\n\n\n","category":"method"}]
}
